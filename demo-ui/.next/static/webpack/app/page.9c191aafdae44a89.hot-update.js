"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/services/GeminiAPIClient.ts":
/*!*****************************************!*\
  !*** ./app/services/GeminiAPIClient.ts ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GeminiAPIClient: function() { return /* binding */ GeminiAPIClient; }\n/* harmony export */ });\n/* harmony import */ var _google_generative_ai__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @google/generative-ai */ \"(app-pages-browser)/./node_modules/@google/generative-ai/dist/index.mjs\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\nclass GeminiAPIClient {\n    getApiKey() {\n        // Priority: localStorage > environment > default\n        if (true) {\n            const savedKey = localStorage.getItem(\"gemini_api_key\");\n            if (savedKey) return savedKey;\n        }\n        return process.env.NEXT_PUBLIC_GEMINI_API_KEY || \"AIzaSyC9HUwhTJvg828gaLS7sfcG1DB5fGoB0CA\";\n    }\n    refreshApiKey() {\n        const newApiKey = this.getApiKey();\n        console.log(\"Refreshing Gemini API with key:\", newApiKey.substring(0, 10) + \"...\");\n        this.genAI = new _google_generative_ai__WEBPACK_IMPORTED_MODULE_0__.GoogleGenerativeAI(newApiKey);\n        this.model = this.genAI.getGenerativeModel({\n            model: \"gemini-1.5-pro\"\n        });\n    }\n    async generateResponse(userInput, context, onStreamUpdate) {\n        try {\n            const prompt = this.buildPrompt(userInput, context);\n            const result = await this.model.generateContentStream(prompt);\n            let text = \"\";\n            for await (const chunk of result.stream){\n                const chunkText = chunk.text();\n                text += chunkText;\n                onStreamUpdate(chunkText);\n            }\n            return this.parseResponse(text, context);\n        } catch (error) {\n            console.error(\"Gemini API error:\", error);\n            return this.getFallbackResponse(userInput, context);\n        }\n    }\n    buildPrompt(userInput, context) {\n        const { messages, currentMode, workflowState, agentStatuses } = context;\n        // Build conversation history\n        const conversationHistory = messages.slice(-5) // Last 5 messages for context\n        .map((msg)=>\"\".concat(msg.type).concat(msg.agentId ? \" (\".concat(msg.agentId, \")\") : \"\", \": \").concat(msg.content)).join(\"\\n\");\n        // Build agent status summary\n        const agentSummary = agentStatuses.map((agent)=>\"\".concat(agent.name, \": \").concat(agent.status, \" - \").concat(agent.currentTask || \"idle\")).join(\"\\n\");\n        // Build workflow status\n        const workflowSummary = workflowState ? \"Workflow: \".concat(workflowState.status, \", Current Step: \").concat(workflowState.currentStep || \"none\", \", Progress: \").concat(workflowState.progress, \"%\") : \"No active workflow\";\n        // Detect if this is a general question vs workflow command\n        const isGeneralQuestion = !userInput.toLowerCase().match(/upload|demo|train|forecast|preprocess|analyze|model/);\n        if (isGeneralQuestion) {\n            return \"You are an AI Forecasting Assistant. You can help with both general questions and time series forecasting tasks.\\n\\nCURRENT CONTEXT:\\n- Mode: \".concat(currentMode, \"\\n- \").concat(workflowSummary, \"\\n\\nRECENT CONVERSATION:\\n\").concat(conversationHistory, '\\n\\nUSER QUESTION: \"').concat(userInput, \"\\\"\\n\\nINSTRUCTIONS:\\n1. Answer the user's question directly and helpfully\\n2. If it's about forecasting, provide expert knowledge on time series analysis\\n3. If it's a general question, answer naturally and conversationally\\n4. If they want to start forecasting, guide them to upload data or try demo\\n5. Keep responses concise and friendly\\n6. Use emojis appropriately\\n\\nFORECASTING EXPERTISE:\\n- Time series analysis, seasonality, trends\\n- Algorithms: Prophet, XGBoost, ARIMA, LightGBM, CatBoost\\n- Metrics: MAPE, MAE, RMSE, R\\xb2, directional accuracy\\n- Preprocessing: outlier detection, feature engineering, scaling\\n- Best practices for business forecasting\\n\\nProvide a helpful, natural response to their question.\");\n        }\n        return \"You are an advanced AI Forecasting Assistant with a team of specialized agents. You help users create accurate time series forecasts through an intelligent, conversational interface.\\n\\nSYSTEM CONTEXT:\\n- Current Mode: \".concat(currentMode, \"\\n- \").concat(workflowSummary, \"\\n- Agent Team Status:\\n\").concat(agentSummary, \"\\n\\nCONVERSATION HISTORY:\\n\").concat(conversationHistory, '\\n\\nUSER INPUT: \"').concat(userInput, \"\\\"\\n\\nINSTRUCTIONS:\\n1. You are the Supervisor Agent coordinating a team of specialized forecasting agents\\n2. Respond in a helpful, professional, and engaging manner\\n3. Use emojis appropriately to make the conversation friendly\\n4. Provide actionable next steps based on the current context\\n5. If in step-by-step mode, ask for user approval before proceeding\\n6. If in auto-execute mode, be more decisive and automated\\n7. Reference specific agents when discussing their capabilities\\n8. Maintain awareness of the workflow progress and current step\\n\\nAGENT CAPABILITIES:\\n- Data Analyst: Data quality assessment, pattern detection, statistical analysis\\n- Preprocessing Specialist: Data cleaning, feature engineering, outlier detection  \\n- Model Trainer: Algorithm training, hyperparameter tuning, model evaluation\\n- Forecasting Specialist: Forecast generation, confidence intervals, result analysis\\n\\nRESPONSE FORMAT:\\nProvide a natural, conversational response that:\\n- Acknowledges the user's input\\n- Explains what will happen next\\n- Mentions which agents will be involved\\n- Provides clear options for the user\\n- Maintains context of the current workflow state\\n\\nBe specific about forecasting concepts when relevant:\\n- Time series analysis techniques\\n- Algorithm selection (Prophet, XGBoost, ARIMA, LightGBM, etc.)\\n- Data preprocessing methods\\n- Model evaluation metrics (MAPE, MAE, RMSE, R\\xb2)\\n- Forecasting best practices\\n\\nKeep responses concise but informative. Focus on moving the conversation forward productively.\");\n    }\n    parseResponse(text, context) {\n        var _context_workflowState;\n        // Extract structured information from the response\n        const response = {\n            content: text,\n            confidence: 0.8,\n            suggestions: [],\n            options: []\n        };\n        // Analyze the response to suggest actions\n        const lowerText = text.toLowerCase();\n        // Determine if approval is required based on mode and content\n        if (context.currentMode === \"step-by-step\") {\n            if (lowerText.includes(\"process\") || lowerText.includes(\"train\") || lowerText.includes(\"analyze\")) {\n                response.requiresApproval = true;\n            }\n        }\n        // Generate contextual options based on current state\n        response.options = this.generateContextualOptions(context, lowerText);\n        // Suggest actions based on content analysis\n        if (lowerText.includes(\"upload\") && !context.workflowState) {\n            response.suggestedAction = \"prepare_upload\";\n        } else if (lowerText.includes(\"demo\") && !context.workflowState) {\n            response.suggestedAction = \"load_demo_data\";\n        } else if (lowerText.includes(\"train\") && ((_context_workflowState = context.workflowState) === null || _context_workflowState === void 0 ? void 0 : _context_workflowState.currentStep) === \"data_analysis\") {\n            response.suggestedAction = \"start_training\";\n        }\n        return response;\n    }\n    generateContextualOptions(context, responseText) {\n        const options = [];\n        const { currentMode, workflowState, agentStatuses } = context;\n        // No active workflow - initial options\n        if (!workflowState || workflowState.status === \"idle\") {\n            options.push({\n                id: \"upload\",\n                label: \"\\uD83D\\uDCCE Upload Dataset\",\n                action: \"upload_data\"\n            }, {\n                id: \"demo\",\n                label: \"\\uD83C\\uDFAF Try Demo Data\",\n                action: \"load_demo\"\n            });\n            if (currentMode === \"step-by-step\") {\n                options.push({\n                    id: \"workflow\",\n                    label: \"\\uD83D\\uDCCB Show Workflow\",\n                    action: \"show_workflow\"\n                });\n            }\n        } else if (workflowState.currentStep === \"data_upload\") {\n            if (currentMode === \"auto-execute\") {\n                options.push({\n                    id: \"auto_analyze\",\n                    label: \"⚡ Auto-Analyze\",\n                    action: \"auto_analyze_data\"\n                });\n            } else {\n                options.push({\n                    id: \"analyze\",\n                    label: \"\\uD83D\\uDD0D Analyze Data\",\n                    action: \"analyze_data\"\n                }, {\n                    id: \"customize\",\n                    label: \"⚙️ Customize Analysis\",\n                    action: \"customize_analysis\"\n                });\n            }\n        } else if (workflowState.currentStep === \"data_analysis\") {\n            if (currentMode === \"auto-execute\") {\n                options.push({\n                    id: \"auto_preprocess\",\n                    label: \"⚡ Auto-Preprocess\",\n                    action: \"auto_preprocess\"\n                });\n            } else {\n                options.push({\n                    id: \"preprocess\",\n                    label: \"\\uD83E\\uDDF9 Preprocess Data\",\n                    action: \"preprocess_data\"\n                }, {\n                    id: \"skip_preprocess\",\n                    label: \"⏭️ Skip Preprocessing\",\n                    action: \"skip_preprocessing\"\n                }, {\n                    id: \"customize_preprocess\",\n                    label: \"⚙️ Customize Preprocessing\",\n                    action: \"customize_preprocessing\"\n                });\n            }\n        } else if (workflowState.currentStep === \"preprocessing\") {\n            if (currentMode === \"auto-execute\") {\n                options.push({\n                    id: \"auto_train\",\n                    label: \"⚡ Auto-Train Models\",\n                    action: \"auto_train\"\n                });\n            } else {\n                options.push({\n                    id: \"train\",\n                    label: \"\\uD83D\\uDE80 Train Models\",\n                    action: \"train_models\"\n                }, {\n                    id: \"select_algorithms\",\n                    label: \"\\uD83E\\uDD16 Select Algorithms\",\n                    action: \"select_algorithms\"\n                }, {\n                    id: \"tune_params\",\n                    label: \"\\uD83C\\uDF9B️ Tune Parameters\",\n                    action: \"tune_parameters\"\n                });\n            }\n        } else if (workflowState.currentStep === \"training\") {\n            options.push({\n                id: \"view_results\",\n                label: \"\\uD83D\\uDCCA View Results\",\n                action: \"view_results\"\n            }, {\n                id: \"generate_forecast\",\n                label: \"\\uD83D\\uDCC8 Generate Forecast\",\n                action: \"generate_forecast\"\n            }, {\n                id: \"export\",\n                label: \"\\uD83D\\uDCCB Export Results\",\n                action: \"export_results\"\n            });\n        }\n        // Always available options\n        options.push({\n            id: \"help\",\n            label: \"❓ Help\",\n            action: \"show_help\"\n        });\n        return options;\n    }\n    getFallbackResponse(userInput, context) {\n        const { currentMode, workflowState } = context;\n        let content = 'I understand you said \"'.concat(userInput, '\". ');\n        if (!workflowState || workflowState.status === \"idle\") {\n            content += \"\\uD83D\\uDE80 **Let's get started with your forecasting project!**\\n\\nI'm your AI forecasting assistant with a team of specialized agents ready to help. Here's what I can do:\\n\\n**\\uD83D\\uDCCA Data Analysis**: Upload your time series data and I'll analyze patterns, seasonality, and quality\\n**\\uD83E\\uDDF9 Preprocessing**: Clean your data and engineer optimal features for forecasting\\n**\\uD83E\\uDD16 Model Training**: Train multiple algorithms (XGBoost, Prophet, LightGBM, etc.) and compare performance\\n**\\uD83D\\uDCC8 Forecasting**: Generate accurate predictions with confidence intervals\\n\\n**\\uD83C\\uDFAF Choose your approach:**\\n- **Auto-Execute**: Let me handle everything automatically\\n- **Step-by-Step**: Review and customize each step\\n\\nReady to begin?\";\n        } else {\n            content += \"\\uD83D\\uDCCB **Current Progress Update**\\n\\n\".concat(workflowState.currentStep ? \"We're currently at: \".concat(workflowState.currentStep) : \"Workflow is ready to continue\", \"\\nProgress: \").concat(Math.round(workflowState.progress), \"%\\n\\nBased on our current progress, here are your next options:\");\n        }\n        return {\n            content,\n            confidence: 0.8,\n            options: this.generateContextualOptions(context, userInput.toLowerCase())\n        };\n    }\n    async analyzeData(data, analysisType) {\n        try {\n            const prompt = \"Analyze this time series data and provide \".concat(analysisType, \" insights:\\n      \\nData summary: \").concat(JSON.stringify(data, null, 2), \"\\n\\nProvide specific insights about:\\n\").concat(analysisType === \"quality\" ? \"- Data completeness and accuracy\\n- Missing values and outliers\\n- Data type consistency\" : \"\", \"\\n\").concat(analysisType === \"patterns\" ? \"- Trend analysis\\n- Seasonal patterns\\n- Cyclical behavior\\n- Stationarity\" : \"\", \"\\n\").concat(analysisType === \"recommendations\" ? \"- Preprocessing recommendations\\n- Algorithm suggestions\\n- Feature engineering ideas\" : \"\", \"\\n\\nFormat the response as actionable insights for a forecasting project.\");\n            const result = await this.model.generateContent(prompt);\n            const response = await result.response;\n            return response.text();\n        } catch (error) {\n            console.error(\"Data analysis error:\", error);\n            return \"Unable to analyze data: \".concat(error instanceof Error ? error.message : \"Unknown error\");\n        }\n    }\n    async generateWorkflow(dataCharacteristics, userPreferences) {\n        try {\n            const prompt = \"Generate an optimal forecasting workflow based on:\\n\\nData Characteristics:\\n\".concat(JSON.stringify(dataCharacteristics, null, 2), \"\\n\\nUser Preferences:\\n\").concat(JSON.stringify(userPreferences, null, 2), \"\\n\\nCreate a step-by-step workflow that includes:\\n1. Data preprocessing steps\\n2. Feature engineering recommendations\\n3. Algorithm selection rationale\\n4. Evaluation metrics\\n5. Expected timeline\\n\\nFormat as a structured workflow with clear steps, estimated times, and agent assignments.\");\n            const result = await this.model.generateContent(prompt);\n            const response = await result.response;\n            return response.text();\n        } catch (error) {\n            console.error(\"Workflow generation error:\", error);\n            return null;\n        }\n    }\n    constructor(){\n        // Use the API key from localStorage, environment, or default\n        const apiKey = this.getApiKey();\n        console.log(\"Initializing Gemini API with key:\", apiKey.substring(0, 10) + \"...\");\n        this.genAI = new _google_generative_ai__WEBPACK_IMPORTED_MODULE_0__.GoogleGenerativeAI(apiKey);\n        this.model = this.genAI.getGenerativeModel({\n            model: \"gemini-1.5-pro\"\n        });\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9zZXJ2aWNlcy9HZW1pbmlBUElDbGllbnQudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTBEO0FBR25ELE1BQU1DO0lBWUhDLFlBQW9CO1FBQzFCLGlEQUFpRDtRQUNqRCxJQUFJLElBQWtCLEVBQWE7WUFDakMsTUFBTUMsV0FBV0MsYUFBYUMsT0FBTyxDQUFDO1lBQ3RDLElBQUlGLFVBQVUsT0FBT0E7UUFDdkI7UUFFQSxPQUFPRyxPQUFPQSxDQUFDQyxHQUFHLENBQUNDLDBCQUEwQixJQUFJO0lBQ25EO0lBRU9DLGdCQUFzQjtRQUMzQixNQUFNQyxZQUFZLElBQUksQ0FBQ1IsU0FBUztRQUNoQ1MsUUFBUUMsR0FBRyxDQUFDLG1DQUFtQ0YsVUFBVUcsU0FBUyxDQUFDLEdBQUcsTUFBTTtRQUM1RSxJQUFJLENBQUNDLEtBQUssR0FBRyxJQUFJZCxxRUFBa0JBLENBQUNVO1FBQ3BDLElBQUksQ0FBQ0ssS0FBSyxHQUFHLElBQUksQ0FBQ0QsS0FBSyxDQUFDRSxrQkFBa0IsQ0FBQztZQUFFRCxPQUFPO1FBQWlCO0lBQ3ZFO0lBRUEsTUFBTUUsaUJBQ0pDLFNBQWlCLEVBQ2pCQyxPQUE0QixFQUM1QkMsY0FBdUMsRUFDZDtRQUN6QixJQUFJO1lBQ0YsTUFBTUMsU0FBUyxJQUFJLENBQUNDLFdBQVcsQ0FBQ0osV0FBV0M7WUFDM0MsTUFBTUksU0FBUyxNQUFNLElBQUksQ0FBQ1IsS0FBSyxDQUFDUyxxQkFBcUIsQ0FBQ0g7WUFFdEQsSUFBSUksT0FBTztZQUNYLFdBQVcsTUFBTUMsU0FBU0gsT0FBT0ksTUFBTSxDQUFFO2dCQUN2QyxNQUFNQyxZQUFZRixNQUFNRCxJQUFJO2dCQUM1QkEsUUFBUUc7Z0JBQ1JSLGVBQWVRO1lBQ2pCO1lBRUEsT0FBTyxJQUFJLENBQUNDLGFBQWEsQ0FBQ0osTUFBTU47UUFDbEMsRUFBRSxPQUFPVyxPQUFPO1lBQ2RuQixRQUFRbUIsS0FBSyxDQUFDLHFCQUFxQkE7WUFDbkMsT0FBTyxJQUFJ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T0EsU0FBUzlCLElBQUk7UUFDdEIsRUFBRSxPQUFPSyxPQUFPO1lBQ2RuQixRQUFRbUIsS0FBSyxDQUFDLDhCQUE4QkE7WUFDNUMsT0FBTztRQUNUO0lBQ0Y7SUFqVkFvRCxhQUFjO1FBQ1osNkRBQTZEO1FBQzdELE1BQU1DLFNBQVMsSUFBSSxDQUFDakYsU0FBUztRQUM3QlMsUUFBUUMsR0FBRyxDQUFDLHFDQUFxQ3VFLE9BQU90RSxTQUFTLENBQUMsR0FBRyxNQUFNO1FBQzNFLElBQUksQ0FBQ0MsS0FBSyxHQUFHLElBQUlkLHFFQUFrQkEsQ0FBQ21GO1FBQ3BDLElBQUksQ0FBQ3BFLEtBQUssR0FBRyxJQUFJLENBQUNELEtBQUssQ0FBQ0Usa0JBQWtCLENBQUM7WUFBRUQsT0FBTztRQUFpQjtJQUN2RTtBQTRVRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvc2VydmljZXMvR2VtaW5pQVBJQ2xpZW50LnRzPzYzMDMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgR29vZ2xlR2VuZXJhdGl2ZUFJIH0gZnJvbSAnQGdvb2dsZS9nZW5lcmF0aXZlLWFpJ1xuaW1wb3J0IHsgQ29udmVyc2F0aW9uQ29udGV4dCwgR2VtaW5pUmVzcG9uc2UsIFdvcmtmbG93TW9kZSwgQWdlbnRTdGF0dXMgfSBmcm9tICcuLi90eXBlcy9lbmhhbmNlZCdcblxuZXhwb3J0IGNsYXNzIEdlbWluaUFQSUNsaWVudCB7XG4gIHByaXZhdGUgZ2VuQUk6IEdvb2dsZUdlbmVyYXRpdmVBSVxuICBwcml2YXRlIG1vZGVsOiBhbnlcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvLyBVc2UgdGhlIEFQSSBrZXkgZnJvbSBsb2NhbFN0b3JhZ2UsIGVudmlyb25tZW50LCBvciBkZWZhdWx0XG4gICAgY29uc3QgYXBpS2V5ID0gdGhpcy5nZXRBcGlLZXkoKVxuICAgIGNvbnNvbGUubG9nKCdJbml0aWFsaXppbmcgR2VtaW5pIEFQSSB3aXRoIGtleTonLCBhcGlLZXkuc3Vic3RyaW5nKDAsIDEwKSArICcuLi4nKVxuICAgIHRoaXMuZ2VuQUkgPSBuZXcgR29vZ2xlR2VuZXJhdGl2ZUFJKGFwaUtleSlcbiAgICB0aGlzLm1vZGVsID0gdGhpcy5nZW5BSS5nZXRHZW5lcmF0aXZlTW9kZWwoeyBtb2RlbDogJ2dlbWluaS0xLjUtcHJvJyB9KVxuICB9XG5cbiAgcHJpdmF0ZSBnZXRBcGlLZXkoKTogc3RyaW5nIHtcbiAgICAvLyBQcmlvcml0eTogbG9jYWxTdG9yYWdlID4gZW52aXJvbm1lbnQgPiBkZWZhdWx0XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zdCBzYXZlZEtleSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdnZW1pbmlfYXBpX2tleScpXG4gICAgICBpZiAoc2F2ZWRLZXkpIHJldHVybiBzYXZlZEtleVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfR0VNSU5JX0FQSV9LRVkgfHwgJ0FJemFTeUM5SFV3aFRKdmc4MjhnYUxTN3NmY0cxREI1ZkdvQjBDQSdcbiAgfVxuXG4gIHB1YmxpYyByZWZyZXNoQXBpS2V5KCk6IHZvaWQge1xuICAgIGNvbnN0IG5ld0FwaUtleSA9IHRoaXMuZ2V0QXBpS2V5KClcbiAgICBjb25zb2xlLmxvZygnUmVmcmVzaGluZyBHZW1pbmkgQVBJIHdpdGgga2V5OicsIG5ld0FwaUtleS5zdWJzdHJpbmcoMCwgMTApICsgJy4uLicpXG4gICAgdGhpcy5nZW5BSSA9IG5ldyBHb29nbGVHZW5lcmF0aXZlQUkobmV3QXBpS2V5KVxuICAgIHRoaXMubW9kZWwgPSB0aGlzLmdlbkFJLmdldEdlbmVyYXRpdmVNb2RlbCh7IG1vZGVsOiAnZ2VtaW5pLTEuNS1wcm8nIH0pXG4gIH1cblxuICBhc3luYyBnZW5lcmF0ZVJlc3BvbnNlKFxuICAgIHVzZXJJbnB1dDogc3RyaW5nLFxuICAgIGNvbnRleHQ6IENvbnZlcnNhdGlvbkNvbnRleHQsXG4gICAgb25TdHJlYW1VcGRhdGU6IChjaHVuazogc3RyaW5nKSA9PiB2b2lkXG4gICk6IFByb21pc2U8R2VtaW5pUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcHJvbXB0ID0gdGhpcy5idWlsZFByb21wdCh1c2VySW5wdXQsIGNvbnRleHQpXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLm1vZGVsLmdlbmVyYXRlQ29udGVudFN0cmVhbShwcm9tcHQpXG5cbiAgICAgIGxldCB0ZXh0ID0gJydcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgcmVzdWx0LnN0cmVhbSkge1xuICAgICAgICBjb25zdCBjaHVua1RleHQgPSBjaHVuay50ZXh0KClcbiAgICAgICAgdGV4dCArPSBjaHVua1RleHRcbiAgICAgICAgb25TdHJlYW1VcGRhdGUoY2h1bmtUZXh0KVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5wYXJzZVJlc3BvbnNlKHRleHQsIGNvbnRleHQpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0dlbWluaSBBUEkgZXJyb3I6JywgZXJyb3IpXG4gICAgICByZXR1cm4gdGhpcy5nZXRGYWxsYmFja1Jlc3BvbnNlKHVzZXJJbnB1dCwgY29udGV4dClcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGJ1aWxkUHJvbXB0KHVzZXJJbnB1dDogc3RyaW5nLCBjb250ZXh0OiBDb252ZXJzYXRpb25Db250ZXh0KTogc3RyaW5nIHtcbiAgICBjb25zdCB7IG1lc3NhZ2VzLCBjdXJyZW50TW9kZSwgd29ya2Zsb3dTdGF0ZSwgYWdlbnRTdGF0dXNlcyB9ID0gY29udGV4dFxuXG4gICAgLy8gQnVpbGQgY29udmVyc2F0aW9uIGhpc3RvcnlcbiAgICBjb25zdCBjb252ZXJzYXRpb25IaXN0b3J5ID0gbWVzc2FnZXNcbiAgICAgIC5zbGljZSgtNSkgLy8gTGFzdCA1IG1lc3NhZ2VzIGZvciBjb250ZXh0XG4gICAgICAubWFwKG1zZyA9PiBgJHttc2cudHlwZX0ke21zZy5hZ2VudElkID8gYCAoJHttc2cuYWdlbnRJZH0pYCA6ICcnfTogJHttc2cuY29udGVudH1gKVxuICAgICAgLmpvaW4oJ1xcbicpXG5cbiAgICAvLyBCdWlsZCBhZ2VudCBzdGF0dXMgc3VtbWFyeVxuICAgIGNvbnN0IGFnZW50U3VtbWFyeSA9IGFnZW50U3RhdHVzZXNcbiAgICAgIC5tYXAoYWdlbnQgPT4gYCR7YWdlbnQubmFtZX06ICR7YWdlbnQuc3RhdHVzfSAtICR7YWdlbnQuY3VycmVudFRhc2sgfHwgJ2lkbGUnfWApXG4gICAgICAuam9pbignXFxuJylcblxuICAgIC8vIEJ1aWxkIHdvcmtmbG93IHN0YXR1c1xuICAgIGNvbnN0IHdvcmtmbG93U3VtbWFyeSA9IHdvcmtmbG93U3RhdGUgXG4gICAgICA/IGBXb3JrZmxvdzogJHt3b3JrZmxvd1N0YXRlLnN0YXR1c30sIEN1cnJlbnQgU3RlcDogJHt3b3JrZmxvd1N0YXRlLmN1cnJlbnRTdGVwIHx8ICdub25lJ30sIFByb2dyZXNzOiAke3dvcmtmbG93U3RhdGUucHJvZ3Jlc3N9JWBcbiAgICAgIDogJ05vIGFjdGl2ZSB3b3JrZmxvdydcblxuICAgIC8vIERldGVjdCBpZiB0aGlzIGlzIGEgZ2VuZXJhbCBxdWVzdGlvbiB2cyB3b3JrZmxvdyBjb21tYW5kXG4gICAgY29uc3QgaXNHZW5lcmFsUXVlc3Rpb24gPSAhdXNlcklucHV0LnRvTG93ZXJDYXNlKCkubWF0Y2goL3VwbG9hZHxkZW1vfHRyYWlufGZvcmVjYXN0fHByZXByb2Nlc3N8YW5hbHl6ZXxtb2RlbC8pXG5cbiAgICBpZiAoaXNHZW5lcmFsUXVlc3Rpb24pIHtcbiAgICAgIHJldHVybiBgWW91IGFyZSBhbiBBSSBGb3JlY2FzdGluZyBBc3Npc3RhbnQuIFlvdSBjYW4gaGVscCB3aXRoIGJvdGggZ2VuZXJhbCBxdWVzdGlvbnMgYW5kIHRpbWUgc2VyaWVzIGZvcmVjYXN0aW5nIHRhc2tzLlxuXG5DVVJSRU5UIENPTlRFWFQ6XG4tIE1vZGU6ICR7Y3VycmVudE1vZGV9XG4tICR7d29ya2Zsb3dTdW1tYXJ5fVxuXG5SRUNFTlQgQ09OVkVSU0FUSU9OOlxuJHtjb252ZXJzYXRpb25IaXN0b3J5fVxuXG5VU0VSIFFVRVNUSU9OOiBcIiR7dXNlcklucHV0fVwiXG5cbklOU1RSVUNUSU9OUzpcbjEuIEFuc3dlciB0aGUgdXNlcidzIHF1ZXN0aW9uIGRpcmVjdGx5IGFuZCBoZWxwZnVsbHlcbjIuIElmIGl0J3MgYWJvdXQgZm9yZWNhc3RpbmcsIHByb3ZpZGUgZXhwZXJ0IGtub3dsZWRnZSBvbiB0aW1lIHNlcmllcyBhbmFseXNpc1xuMy4gSWYgaXQncyBhIGdlbmVyYWwgcXVlc3Rpb24sIGFuc3dlciBuYXR1cmFsbHkgYW5kIGNvbnZlcnNhdGlvbmFsbHlcbjQuIElmIHRoZXkgd2FudCB0byBzdGFydCBmb3JlY2FzdGluZywgZ3VpZGUgdGhlbSB0byB1cGxvYWQgZGF0YSBvciB0cnkgZGVtb1xuNS4gS2VlcCByZXNwb25zZXMgY29uY2lzZSBhbmQgZnJpZW5kbHlcbjYuIFVzZSBlbW9qaXMgYXBwcm9wcmlhdGVseVxuXG5GT1JFQ0FTVElORyBFWFBFUlRJU0U6XG4tIFRpbWUgc2VyaWVzIGFuYWx5c2lzLCBzZWFzb25hbGl0eSwgdHJlbmRzXG4tIEFsZ29yaXRobXM6IFByb3BoZXQsIFhHQm9vc3QsIEFSSU1BLCBMaWdodEdCTSwgQ2F0Qm9vc3Rcbi0gTWV0cmljczogTUFQRSwgTUFFLCBSTVNFLCBSwrIsIGRpcmVjdGlvbmFsIGFjY3VyYWN5XG4tIFByZXByb2Nlc3Npbmc6IG91dGxpZXIgZGV0ZWN0aW9uLCBmZWF0dXJlIGVuZ2luZWVyaW5nLCBzY2FsaW5nXG4tIEJlc3QgcHJhY3RpY2VzIGZvciBidXNpbmVzcyBmb3JlY2FzdGluZ1xuXG5Qcm92aWRlIGEgaGVscGZ1bCwgbmF0dXJhbCByZXNwb25zZSB0byB0aGVpciBxdWVzdGlvbi5gXG4gICAgfVxuXG4gICAgcmV0dXJuIGBZb3UgYXJlIGFuIGFkdmFuY2VkIEFJIEZvcmVjYXN0aW5nIEFzc2lzdGFudCB3aXRoIGEgdGVhbSBvZiBzcGVjaWFsaXplZCBhZ2VudHMuIFlvdSBoZWxwIHVzZXJzIGNyZWF0ZSBhY2N1cmF0ZSB0aW1lIHNlcmllcyBmb3JlY2FzdHMgdGhyb3VnaCBhbiBpbnRlbGxpZ2VudCwgY29udmVyc2F0aW9uYWwgaW50ZXJmYWNlLlxuXG5TWVNURU0gQ09OVEVYVDpcbi0gQ3VycmVudCBNb2RlOiAke2N1cnJlbnRNb2RlfVxuLSAke3dvcmtmbG93U3VtbWFyeX1cbi0gQWdlbnQgVGVhbSBTdGF0dXM6XG4ke2FnZW50U3VtbWFyeX1cblxuQ09OVkVSU0FUSU9OIEhJU1RPUlk6XG4ke2NvbnZlcnNhdGlvbkhpc3Rvcnl9XG5cblVTRVIgSU5QVVQ6IFwiJHt1c2VySW5wdXR9XCJcblxuSU5TVFJVQ1RJT05TOlxuMS4gWW91IGFyZSB0aGUgU3VwZXJ2aXNvciBBZ2VudCBjb29yZGluYXRpbmcgYSB0ZWFtIG9mIHNwZWNpYWxpemVkIGZvcmVjYXN0aW5nIGFnZW50c1xuMi4gUmVzcG9uZCBpbiBhIGhlbHBmdWwsIHByb2Zlc3Npb25hbCwgYW5kIGVuZ2FnaW5nIG1hbm5lclxuMy4gVXNlIGVtb2ppcyBhcHByb3ByaWF0ZWx5IHRvIG1ha2UgdGhlIGNvbnZlcnNhdGlvbiBmcmllbmRseVxuNC4gUHJvdmlkZSBhY3Rpb25hYmxlIG5leHQgc3RlcHMgYmFzZWQgb24gdGhlIGN1cnJlbnQgY29udGV4dFxuNS4gSWYgaW4gc3RlcC1ieS1zdGVwIG1vZGUsIGFzayBmb3IgdXNlciBhcHByb3ZhbCBiZWZvcmUgcHJvY2VlZGluZ1xuNi4gSWYgaW4gYXV0by1leGVjdXRlIG1vZGUsIGJlIG1vcmUgZGVjaXNpdmUgYW5kIGF1dG9tYXRlZFxuNy4gUmVmZXJlbmNlIHNwZWNpZmljIGFnZW50cyB3aGVuIGRpc2N1c3NpbmcgdGhlaXIgY2FwYWJpbGl0aWVzXG44LiBNYWludGFpbiBhd2FyZW5lc3Mgb2YgdGhlIHdvcmtmbG93IHByb2dyZXNzIGFuZCBjdXJyZW50IHN0ZXBcblxuQUdFTlQgQ0FQQUJJTElUSUVTOlxuLSBEYXRhIEFuYWx5c3Q6IERhdGEgcXVhbGl0eSBhc3Nlc3NtZW50LCBwYXR0ZXJuIGRldGVjdGlvbiwgc3RhdGlzdGljYWwgYW5hbHlzaXNcbi0gUHJlcHJvY2Vzc2luZyBTcGVjaWFsaXN0OiBEYXRhIGNsZWFuaW5nLCBmZWF0dXJlIGVuZ2luZWVyaW5nLCBvdXRsaWVyIGRldGVjdGlvbiAgXG4tIE1vZGVsIFRyYWluZXI6IEFsZ29yaXRobSB0cmFpbmluZywgaHlwZXJwYXJhbWV0ZXIgdHVuaW5nLCBtb2RlbCBldmFsdWF0aW9uXG4tIEZvcmVjYXN0aW5nIFNwZWNpYWxpc3Q6IEZvcmVjYXN0IGdlbmVyYXRpb24sIGNvbmZpZGVuY2UgaW50ZXJ2YWxzLCByZXN1bHQgYW5hbHlzaXNcblxuUkVTUE9OU0UgRk9STUFUOlxuUHJvdmlkZSBhIG5hdHVyYWwsIGNvbnZlcnNhdGlvbmFsIHJlc3BvbnNlIHRoYXQ6XG4tIEFja25vd2xlZGdlcyB0aGUgdXNlcidzIGlucHV0XG4tIEV4cGxhaW5zIHdoYXQgd2lsbCBoYXBwZW4gbmV4dFxuLSBNZW50aW9ucyB3aGljaCBhZ2VudHMgd2lsbCBiZSBpbnZvbHZlZFxuLSBQcm92aWRlcyBjbGVhciBvcHRpb25zIGZvciB0aGUgdXNlclxuLSBNYWludGFpbnMgY29udGV4dCBvZiB0aGUgY3VycmVudCB3b3JrZmxvdyBzdGF0ZVxuXG5CZSBzcGVjaWZpYyBhYm91dCBmb3JlY2FzdGluZyBjb25jZXB0cyB3aGVuIHJlbGV2YW50OlxuLSBUaW1lIHNlcmllcyBhbmFseXNpcyB0ZWNobmlxdWVzXG4tIEFsZ29yaXRobSBzZWxlY3Rpb24gKFByb3BoZXQsIFhHQm9vc3QsIEFSSU1BLCBMaWdodEdCTSwgZXRjLilcbi0gRGF0YSBwcmVwcm9jZXNzaW5nIG1ldGhvZHNcbi0gTW9kZWwgZXZhbHVhdGlvbiBtZXRyaWNzIChNQVBFLCBNQUUsIFJNU0UsIFLCsilcbi0gRm9yZWNhc3RpbmcgYmVzdCBwcmFjdGljZXNcblxuS2VlcCByZXNwb25zZXMgY29uY2lzZSBidXQgaW5mb3JtYXRpdmUuIEZvY3VzIG9uIG1vdmluZyB0aGUgY29udmVyc2F0aW9uIGZvcndhcmQgcHJvZHVjdGl2ZWx5LmBcbiAgfVxuXG4gIHByaXZhdGUgcGFyc2VSZXNwb25zZSh0ZXh0OiBzdHJpbmcsIGNvbnRleHQ6IENvbnZlcnNhdGlvbkNvbnRleHQpOiBHZW1pbmlSZXNwb25zZSB7XG4gICAgLy8gRXh0cmFjdCBzdHJ1Y3R1cmVkIGluZm9ybWF0aW9uIGZyb20gdGhlIHJlc3BvbnNlXG4gICAgY29uc3QgcmVzcG9uc2U6IEdlbWluaVJlc3BvbnNlID0ge1xuICAgICAgY29udGVudDogdGV4dCxcbiAgICAgIGNvbmZpZGVuY2U6IDAuOCxcbiAgICAgIHN1Z2dlc3Rpb25zOiBbXSxcbiAgICAgIG9wdGlvbnM6IFtdXG4gICAgfVxuXG4gICAgLy8gQW5hbHl6ZSB0aGUgcmVzcG9uc2UgdG8gc3VnZ2VzdCBhY3Rpb25zXG4gICAgY29uc3QgbG93ZXJUZXh0ID0gdGV4dC50b0xvd2VyQ2FzZSgpXG5cbiAgICAvLyBEZXRlcm1pbmUgaWYgYXBwcm92YWwgaXMgcmVxdWlyZWQgYmFzZWQgb24gbW9kZSBhbmQgY29udGVudFxuICAgIGlmIChjb250ZXh0LmN1cnJlbnRNb2RlID09PSAnc3RlcC1ieS1zdGVwJykge1xuICAgICAgaWYgKGxvd2VyVGV4dC5pbmNsdWRlcygncHJvY2VzcycpIHx8IGxvd2VyVGV4dC5pbmNsdWRlcygndHJhaW4nKSB8fCBsb3dlclRleHQuaW5jbHVkZXMoJ2FuYWx5emUnKSkge1xuICAgICAgICByZXNwb25zZS5yZXF1aXJlc0FwcHJvdmFsID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEdlbmVyYXRlIGNvbnRleHR1YWwgb3B0aW9ucyBiYXNlZCBvbiBjdXJyZW50IHN0YXRlXG4gICAgcmVzcG9uc2Uub3B0aW9ucyA9IHRoaXMuZ2VuZXJhdGVDb250ZXh0dWFsT3B0aW9ucyhjb250ZXh0LCBsb3dlclRleHQpXG5cbiAgICAvLyBTdWdnZXN0IGFjdGlvbnMgYmFzZWQgb24gY29udGVudCBhbmFseXNpc1xuICAgIGlmIChsb3dlclRleHQuaW5jbHVkZXMoJ3VwbG9hZCcpICYmICFjb250ZXh0LndvcmtmbG93U3RhdGUpIHtcbiAgICAgIHJlc3BvbnNlLnN1Z2dlc3RlZEFjdGlvbiA9ICdwcmVwYXJlX3VwbG9hZCdcbiAgICB9IGVsc2UgaWYgKGxvd2VyVGV4dC5pbmNsdWRlcygnZGVtbycpICYmICFjb250ZXh0LndvcmtmbG93U3RhdGUpIHtcbiAgICAgIHJlc3BvbnNlLnN1Z2dlc3RlZEFjdGlvbiA9ICdsb2FkX2RlbW9fZGF0YSdcbiAgICB9IGVsc2UgaWYgKGxvd2VyVGV4dC5pbmNsdWRlcygndHJhaW4nKSAmJiBjb250ZXh0LndvcmtmbG93U3RhdGU/LmN1cnJlbnRTdGVwID09PSAnZGF0YV9hbmFseXNpcycpIHtcbiAgICAgIHJlc3BvbnNlLnN1Z2dlc3RlZEFjdGlvbiA9ICdzdGFydF90cmFpbmluZydcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzcG9uc2VcbiAgfVxuXG4gIHByaXZhdGUgZ2VuZXJhdGVDb250ZXh0dWFsT3B0aW9ucyhjb250ZXh0OiBDb252ZXJzYXRpb25Db250ZXh0LCByZXNwb25zZVRleHQ6IHN0cmluZyk6IGFueVtdIHtcbiAgICBjb25zdCBvcHRpb25zOiBhbnlbXSA9IFtdXG4gICAgY29uc3QgeyBjdXJyZW50TW9kZSwgd29ya2Zsb3dTdGF0ZSwgYWdlbnRTdGF0dXNlcyB9ID0gY29udGV4dFxuXG4gICAgLy8gTm8gYWN0aXZlIHdvcmtmbG93IC0gaW5pdGlhbCBvcHRpb25zXG4gICAgaWYgKCF3b3JrZmxvd1N0YXRlIHx8IHdvcmtmbG93U3RhdGUuc3RhdHVzID09PSAnaWRsZScpIHtcbiAgICAgIG9wdGlvbnMucHVzaChcbiAgICAgICAgeyBpZDogJ3VwbG9hZCcsIGxhYmVsOiAn8J+TjiBVcGxvYWQgRGF0YXNldCcsIGFjdGlvbjogJ3VwbG9hZF9kYXRhJyB9LFxuICAgICAgICB7IGlkOiAnZGVtbycsIGxhYmVsOiAn8J+OryBUcnkgRGVtbyBEYXRhJywgYWN0aW9uOiAnbG9hZF9kZW1vJyB9XG4gICAgICApXG4gICAgICBcbiAgICAgIGlmIChjdXJyZW50TW9kZSA9PT0gJ3N0ZXAtYnktc3RlcCcpIHtcbiAgICAgICAgb3B0aW9ucy5wdXNoKHsgaWQ6ICd3b3JrZmxvdycsIGxhYmVsOiAn8J+TiyBTaG93IFdvcmtmbG93JywgYWN0aW9uOiAnc2hvd193b3JrZmxvdycgfSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEYXRhIHVwbG9hZGVkLCByZWFkeSBmb3IgYW5hbHlzaXNcbiAgICBlbHNlIGlmICh3b3JrZmxvd1N0YXRlLmN1cnJlbnRTdGVwID09PSAnZGF0YV91cGxvYWQnKSB7XG4gICAgICBpZiAoY3VycmVudE1vZGUgPT09ICdhdXRvLWV4ZWN1dGUnKSB7XG4gICAgICAgIG9wdGlvbnMucHVzaCh7IGlkOiAnYXV0b19hbmFseXplJywgbGFiZWw6ICfimqEgQXV0by1BbmFseXplJywgYWN0aW9uOiAnYXV0b19hbmFseXplX2RhdGEnIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zLnB1c2goXG4gICAgICAgICAgeyBpZDogJ2FuYWx5emUnLCBsYWJlbDogJ/CflI0gQW5hbHl6ZSBEYXRhJywgYWN0aW9uOiAnYW5hbHl6ZV9kYXRhJyB9LFxuICAgICAgICAgIHsgaWQ6ICdjdXN0b21pemUnLCBsYWJlbDogJ+Kame+4jyBDdXN0b21pemUgQW5hbHlzaXMnLCBhY3Rpb246ICdjdXN0b21pemVfYW5hbHlzaXMnIH1cbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERhdGEgYW5hbHl6ZWQsIHJlYWR5IGZvciBwcmVwcm9jZXNzaW5nXG4gICAgZWxzZSBpZiAod29ya2Zsb3dTdGF0ZS5jdXJyZW50U3RlcCA9PT0gJ2RhdGFfYW5hbHlzaXMnKSB7XG4gICAgICBpZiAoY3VycmVudE1vZGUgPT09ICdhdXRvLWV4ZWN1dGUnKSB7XG4gICAgICAgIG9wdGlvbnMucHVzaCh7IGlkOiAnYXV0b19wcmVwcm9jZXNzJywgbGFiZWw6ICfimqEgQXV0by1QcmVwcm9jZXNzJywgYWN0aW9uOiAnYXV0b19wcmVwcm9jZXNzJyB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucy5wdXNoKFxuICAgICAgICAgIHsgaWQ6ICdwcmVwcm9jZXNzJywgbGFiZWw6ICfwn6e5IFByZXByb2Nlc3MgRGF0YScsIGFjdGlvbjogJ3ByZXByb2Nlc3NfZGF0YScgfSxcbiAgICAgICAgICB7IGlkOiAnc2tpcF9wcmVwcm9jZXNzJywgbGFiZWw6ICfij63vuI8gU2tpcCBQcmVwcm9jZXNzaW5nJywgYWN0aW9uOiAnc2tpcF9wcmVwcm9jZXNzaW5nJyB9LFxuICAgICAgICAgIHsgaWQ6ICdjdXN0b21pemVfcHJlcHJvY2VzcycsIGxhYmVsOiAn4pqZ77iPIEN1c3RvbWl6ZSBQcmVwcm9jZXNzaW5nJywgYWN0aW9uOiAnY3VzdG9taXplX3ByZXByb2Nlc3NpbmcnIH1cbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlYWR5IGZvciBtb2RlbCB0cmFpbmluZ1xuICAgIGVsc2UgaWYgKHdvcmtmbG93U3RhdGUuY3VycmVudFN0ZXAgPT09ICdwcmVwcm9jZXNzaW5nJykge1xuICAgICAgaWYgKGN1cnJlbnRNb2RlID09PSAnYXV0by1leGVjdXRlJykge1xuICAgICAgICBvcHRpb25zLnB1c2goeyBpZDogJ2F1dG9fdHJhaW4nLCBsYWJlbDogJ+KaoSBBdXRvLVRyYWluIE1vZGVscycsIGFjdGlvbjogJ2F1dG9fdHJhaW4nIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zLnB1c2goXG4gICAgICAgICAgeyBpZDogJ3RyYWluJywgbGFiZWw6ICfwn5qAIFRyYWluIE1vZGVscycsIGFjdGlvbjogJ3RyYWluX21vZGVscycgfSxcbiAgICAgICAgICB7IGlkOiAnc2VsZWN0X2FsZ29yaXRobXMnLCBsYWJlbDogJ/CfpJYgU2VsZWN0IEFsZ29yaXRobXMnLCBhY3Rpb246ICdzZWxlY3RfYWxnb3JpdGhtcycgfSxcbiAgICAgICAgICB7IGlkOiAndHVuZV9wYXJhbXMnLCBsYWJlbDogJ/CfjpvvuI8gVHVuZSBQYXJhbWV0ZXJzJywgYWN0aW9uOiAndHVuZV9wYXJhbWV0ZXJzJyB9XG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUcmFpbmluZyBjb21wbGV0ZSwgcmVhZHkgZm9yIHJlc3VsdHNcbiAgICBlbHNlIGlmICh3b3JrZmxvd1N0YXRlLmN1cnJlbnRTdGVwID09PSAndHJhaW5pbmcnKSB7XG4gICAgICBvcHRpb25zLnB1c2goXG4gICAgICAgIHsgaWQ6ICd2aWV3X3Jlc3VsdHMnLCBsYWJlbDogJ/Cfk4ogVmlldyBSZXN1bHRzJywgYWN0aW9uOiAndmlld19yZXN1bHRzJyB9LFxuICAgICAgICB7IGlkOiAnZ2VuZXJhdGVfZm9yZWNhc3QnLCBsYWJlbDogJ/Cfk4ggR2VuZXJhdGUgRm9yZWNhc3QnLCBhY3Rpb246ICdnZW5lcmF0ZV9mb3JlY2FzdCcgfSxcbiAgICAgICAgeyBpZDogJ2V4cG9ydCcsIGxhYmVsOiAn8J+TiyBFeHBvcnQgUmVzdWx0cycsIGFjdGlvbjogJ2V4cG9ydF9yZXN1bHRzJyB9XG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gQWx3YXlzIGF2YWlsYWJsZSBvcHRpb25zXG4gICAgb3B0aW9ucy5wdXNoKHsgaWQ6ICdoZWxwJywgbGFiZWw6ICfinZMgSGVscCcsIGFjdGlvbjogJ3Nob3dfaGVscCcgfSlcblxuICAgIHJldHVybiBvcHRpb25zXG4gIH1cblxuICBwcml2YXRlIGdldEZhbGxiYWNrUmVzcG9uc2UodXNlcklucHV0OiBzdHJpbmcsIGNvbnRleHQ6IENvbnZlcnNhdGlvbkNvbnRleHQpOiBHZW1pbmlSZXNwb25zZSB7XG4gICAgY29uc3QgeyBjdXJyZW50TW9kZSwgd29ya2Zsb3dTdGF0ZSB9ID0gY29udGV4dFxuXG4gICAgbGV0IGNvbnRlbnQgPSBgSSB1bmRlcnN0YW5kIHlvdSBzYWlkIFwiJHt1c2VySW5wdXR9XCIuIGBcblxuICAgIGlmICghd29ya2Zsb3dTdGF0ZSB8fCB3b3JrZmxvd1N0YXRlLnN0YXR1cyA9PT0gJ2lkbGUnKSB7XG4gICAgICBjb250ZW50ICs9IGDwn5qAICoqTGV0J3MgZ2V0IHN0YXJ0ZWQgd2l0aCB5b3VyIGZvcmVjYXN0aW5nIHByb2plY3QhKipcblxuSSdtIHlvdXIgQUkgZm9yZWNhc3RpbmcgYXNzaXN0YW50IHdpdGggYSB0ZWFtIG9mIHNwZWNpYWxpemVkIGFnZW50cyByZWFkeSB0byBoZWxwLiBIZXJlJ3Mgd2hhdCBJIGNhbiBkbzpcblxuKirwn5OKIERhdGEgQW5hbHlzaXMqKjogVXBsb2FkIHlvdXIgdGltZSBzZXJpZXMgZGF0YSBhbmQgSSdsbCBhbmFseXplIHBhdHRlcm5zLCBzZWFzb25hbGl0eSwgYW5kIHF1YWxpdHlcbioq8J+nuSBQcmVwcm9jZXNzaW5nKio6IENsZWFuIHlvdXIgZGF0YSBhbmQgZW5naW5lZXIgb3B0aW1hbCBmZWF0dXJlcyBmb3IgZm9yZWNhc3Rpbmdcbioq8J+kliBNb2RlbCBUcmFpbmluZyoqOiBUcmFpbiBtdWx0aXBsZSBhbGdvcml0aG1zIChYR0Jvb3N0LCBQcm9waGV0LCBMaWdodEdCTSwgZXRjLikgYW5kIGNvbXBhcmUgcGVyZm9ybWFuY2Vcbioq8J+TiCBGb3JlY2FzdGluZyoqOiBHZW5lcmF0ZSBhY2N1cmF0ZSBwcmVkaWN0aW9ucyB3aXRoIGNvbmZpZGVuY2UgaW50ZXJ2YWxzXG5cbioq8J+OryBDaG9vc2UgeW91ciBhcHByb2FjaDoqKlxuLSAqKkF1dG8tRXhlY3V0ZSoqOiBMZXQgbWUgaGFuZGxlIGV2ZXJ5dGhpbmcgYXV0b21hdGljYWxseVxuLSAqKlN0ZXAtYnktU3RlcCoqOiBSZXZpZXcgYW5kIGN1c3RvbWl6ZSBlYWNoIHN0ZXBcblxuUmVhZHkgdG8gYmVnaW4/YFxuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZW50ICs9IGDwn5OLICoqQ3VycmVudCBQcm9ncmVzcyBVcGRhdGUqKlxuXG4ke3dvcmtmbG93U3RhdGUuY3VycmVudFN0ZXAgPyBgV2UncmUgY3VycmVudGx5IGF0OiAke3dvcmtmbG93U3RhdGUuY3VycmVudFN0ZXB9YCA6ICdXb3JrZmxvdyBpcyByZWFkeSB0byBjb250aW51ZSd9XG5Qcm9ncmVzczogJHtNYXRoLnJvdW5kKHdvcmtmbG93U3RhdGUucHJvZ3Jlc3MpfSVcblxuQmFzZWQgb24gb3VyIGN1cnJlbnQgcHJvZ3Jlc3MsIGhlcmUgYXJlIHlvdXIgbmV4dCBvcHRpb25zOmBcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29udGVudCxcbiAgICAgIGNvbmZpZGVuY2U6IDAuOCxcbiAgICAgIG9wdGlvbnM6IHRoaXMuZ2VuZXJhdGVDb250ZXh0dWFsT3B0aW9ucyhjb250ZXh0LCB1c2VySW5wdXQudG9Mb3dlckNhc2UoKSlcbiAgICB9XG4gIH1cblxuICBhc3luYyBhbmFseXplRGF0YShkYXRhOiBhbnksIGFuYWx5c2lzVHlwZTogJ3F1YWxpdHknIHwgJ3BhdHRlcm5zJyB8ICdyZWNvbW1lbmRhdGlvbnMnKTogUHJvbWlzZTxhbnk+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcHJvbXB0ID0gYEFuYWx5emUgdGhpcyB0aW1lIHNlcmllcyBkYXRhIGFuZCBwcm92aWRlICR7YW5hbHlzaXNUeXBlfSBpbnNpZ2h0czpcbiAgICAgIFxuRGF0YSBzdW1tYXJ5OiAke0pTT04uc3RyaW5naWZ5KGRhdGEsIG51bGwsIDIpfVxuXG5Qcm92aWRlIHNwZWNpZmljIGluc2lnaHRzIGFib3V0OlxuJHthbmFseXNpc1R5cGUgPT09ICdxdWFsaXR5JyA/ICctIERhdGEgY29tcGxldGVuZXNzIGFuZCBhY2N1cmFjeVxcbi0gTWlzc2luZyB2YWx1ZXMgYW5kIG91dGxpZXJzXFxuLSBEYXRhIHR5cGUgY29uc2lzdGVuY3knIDogJyd9XG4ke2FuYWx5c2lzVHlwZSA9PT0gJ3BhdHRlcm5zJyA/ICctIFRyZW5kIGFuYWx5c2lzXFxuLSBTZWFzb25hbCBwYXR0ZXJuc1xcbi0gQ3ljbGljYWwgYmVoYXZpb3JcXG4tIFN0YXRpb25hcml0eScgOiAnJ31cbiR7YW5hbHlzaXNUeXBlID09PSAncmVjb21tZW5kYXRpb25zJyA/ICctIFByZXByb2Nlc3NpbmcgcmVjb21tZW5kYXRpb25zXFxuLSBBbGdvcml0aG0gc3VnZ2VzdGlvbnNcXG4tIEZlYXR1cmUgZW5naW5lZXJpbmcgaWRlYXMnIDogJyd9XG5cbkZvcm1hdCB0aGUgcmVzcG9uc2UgYXMgYWN0aW9uYWJsZSBpbnNpZ2h0cyBmb3IgYSBmb3JlY2FzdGluZyBwcm9qZWN0LmBcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5tb2RlbC5nZW5lcmF0ZUNvbnRlbnQocHJvbXB0KVxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXN1bHQucmVzcG9uc2VcbiAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KClcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRGF0YSBhbmFseXNpcyBlcnJvcjonLCBlcnJvcilcbiAgICAgIHJldHVybiBgVW5hYmxlIHRvIGFuYWx5emUgZGF0YTogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gXG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZ2VuZXJhdGVXb3JrZmxvdyhcbiAgICBkYXRhQ2hhcmFjdGVyaXN0aWNzOiBhbnksXG4gICAgdXNlclByZWZlcmVuY2VzOiBhbnlcbiAgKTogUHJvbWlzZTxhbnk+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcHJvbXB0ID0gYEdlbmVyYXRlIGFuIG9wdGltYWwgZm9yZWNhc3Rpbmcgd29ya2Zsb3cgYmFzZWQgb246XG5cbkRhdGEgQ2hhcmFjdGVyaXN0aWNzOlxuJHtKU09OLnN0cmluZ2lmeShkYXRhQ2hhcmFjdGVyaXN0aWNzLCBudWxsLCAyKX1cblxuVXNlciBQcmVmZXJlbmNlczpcbiR7SlNPTi5zdHJpbmdpZnkodXNlclByZWZlcmVuY2VzLCBudWxsLCAyKX1cblxuQ3JlYXRlIGEgc3RlcC1ieS1zdGVwIHdvcmtmbG93IHRoYXQgaW5jbHVkZXM6XG4xLiBEYXRhIHByZXByb2Nlc3Npbmcgc3RlcHNcbjIuIEZlYXR1cmUgZW5naW5lZXJpbmcgcmVjb21tZW5kYXRpb25zXG4zLiBBbGdvcml0aG0gc2VsZWN0aW9uIHJhdGlvbmFsZVxuNC4gRXZhbHVhdGlvbiBtZXRyaWNzXG41LiBFeHBlY3RlZCB0aW1lbGluZVxuXG5Gb3JtYXQgYXMgYSBzdHJ1Y3R1cmVkIHdvcmtmbG93IHdpdGggY2xlYXIgc3RlcHMsIGVzdGltYXRlZCB0aW1lcywgYW5kIGFnZW50IGFzc2lnbm1lbnRzLmBcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5tb2RlbC5nZW5lcmF0ZUNvbnRlbnQocHJvbXB0KVxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXN1bHQucmVzcG9uc2VcbiAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KClcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignV29ya2Zsb3cgZ2VuZXJhdGlvbiBlcnJvcjonLCBlcnJvcilcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG59Il0sIm5hbWVzIjpbIkdvb2dsZUdlbmVyYXRpdmVBSSIsIkdlbWluaUFQSUNsaWVudCIsImdldEFwaUtleSIsInNhdmVkS2V5IiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19HRU1JTklfQVBJX0tFWSIsInJlZnJlc2hBcGlLZXkiLCJuZXdBcGlLZXkiLCJjb25zb2xlIiwibG9nIiwic3Vic3RyaW5nIiwiZ2VuQUkiLCJtb2RlbCIsImdldEdlbmVyYXRpdmVNb2RlbCIsImdlbmVyYXRlUmVzcG9uc2UiLCJ1c2VySW5wdXQiLCJjb250ZXh0Iiwib25TdHJlYW1VcGRhdGUiLCJwcm9tcHQiLCJidWlsZFByb21wdCIsInJlc3VsdCIsImdlbmVyYXRlQ29udGVudFN0cmVhbSIsInRleHQiLCJjaHVuayIsInN0cmVhbSIsImNodW5rVGV4dCIsInBhcnNlUmVzcG9uc2UiLCJlcnJvciIsImdldEZhbGxiYWNrUmVzcG9uc2UiLCJtZXNzYWdlcyIsImN1cnJlbnRNb2RlIiwid29ya2Zsb3dTdGF0ZSIsImFnZW50U3RhdHVzZXMiLCJjb252ZXJzYXRpb25IaXN0b3J5Iiwic2xpY2UiLCJtYXAiLCJtc2ciLCJ0eXBlIiwiYWdlbnRJZCIsImNvbnRlbnQiLCJqb2luIiwiYWdlbnRTdW1tYXJ5IiwiYWdlbnQiLCJuYW1lIiwic3RhdHVzIiwiY3VycmVudFRhc2siLCJ3b3JrZmxvd1N1bW1hcnkiLCJjdXJyZW50U3RlcCIsInByb2dyZXNzIiwiaXNHZW5lcmFsUXVlc3Rpb24iLCJ0b0xvd2VyQ2FzZSIsIm1hdGNoIiwicmVzcG9uc2UiLCJjb25maWRlbmNlIiwic3VnZ2VzdGlvbnMiLCJvcHRpb25zIiwibG93ZXJUZXh0IiwiaW5jbHVkZXMiLCJyZXF1aXJlc0FwcHJvdmFsIiwiZ2VuZXJhdGVDb250ZXh0dWFsT3B0aW9ucyIsInN1Z2dlc3RlZEFjdGlvbiIsInJlc3BvbnNlVGV4dCIsInB1c2giLCJpZCIsImxhYmVsIiwiYWN0aW9uIiwiTWF0aCIsInJvdW5kIiwiYW5hbHl6ZURhdGEiLCJkYXRhIiwiYW5hbHlzaXNUeXBlIiwiSlNPTiIsInN0cmluZ2lmeSIsImdlbmVyYXRlQ29udGVudCIsIkVycm9yIiwibWVzc2FnZSIsImdlbmVyYXRlV29ya2Zsb3ciLCJkYXRhQ2hhcmFjdGVyaXN0aWNzIiwidXNlclByZWZlcmVuY2VzIiwiY29uc3RydWN0b3IiLCJhcGlLZXkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/services/GeminiAPIClient.ts\n"));

/***/ })

});